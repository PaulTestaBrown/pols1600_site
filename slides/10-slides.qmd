---
title: "POLS 1600"
subtitle: "Quantifying uncertainty:<br> Confidence Intervals &<br>Hypothesis Tests"
date: last-modified
date-format: "[Updated ]MMM D, YYYY"
format: 
  revealjs:
    theme: brownslides.scss
    logo: images/pols1600_hex.png
    footer: "POLS 1600"
    multiplex: false
    transition: fade
    slide-number: c
    incremental: true
    center: false
    menu: true
    scrollable: true
    highlight-style: github
    progress: true
    code-overflow: wrap
    chalkboard: true
    # include-after-body: title-slide.html
    title-slide-attributes:
      align: left
      data-background-image: images/pols1600_hex.png
      data-background-position: 90% 50%
      data-background-size: 40%
filters:
  - openlinksinnewpage
execute: 
  eval: true
  echo: true
  warning: false
  message: false
  cache: true
---


```{r}
#| label: init
#| echo: false
#| results: hide
#| warning: false 
#| message: false

library(tidyverse)
library(labelled)
library(haven)
library(DeclareDesign)
library(easystats)
library(texreg)

```



# {{< fa map-location>}} Overview {.inverse}

## Class Plan

- Announcements
- Feedback
- Review
- Class plan


## Annoucements

## Feedback

## {{< fa lightbulb >}}  Concepts 

## {{< fa code>}} Code   

# {{< fa magnifying-glass>}} Review {.inverse}

## Review

# {{< fa lightbulb >}} Confidence Intervals {.inverse}


## Confidence Intervals{.smaller}

- Confidence intervals provide a way of [quantifying uncertainty]{.blue} about [estimates]{.blue}

- Confidence intervals describe a [range of plausible values]{.blue} for an estimate

- That range is a function of the [standard error]{.blue} of the estimate, and the a [critical value]{.blue} determined by $\alpha$, which describes the degree of confidence we want 
  
  - A 95% confidence interval corresponds to an $\alpha$ of 0.05

- A [standard error]{.blue} is the standard deviation of a theoretical [sampling distribution]{.blue} of our estimate

- We can obtain the sampling distribution via:

  - [simulation]{.blue} (bootstrapping)
  - [asymptotic theory]{.blue} (the CLT)

- Our confidence [is about the interval]{.blue}, not the specific value of the estimate.

## Populations and Samples{.smaller}


- [Population]{.blue: All the cases from which you could have sampled

- [Parameter:]{.blue} A quantity or quantities of interest often generically called $\theta$ ("theta"). Something we'd like to know about our population

- [Sample:]{.blue} A (random) draw from that population

- [Sample Size:]{.blue} The number of observations in your draw (without replacement)

## Estimators, Estimates, and Statistics{.smaller}

- [Estimator:]{.blue} A rule for calculating an *estimate* of our parameter of interest. 

- [Estimate:]{.blue} The value produced by some estimator for some parameter from some data. Often called $\hat{\theta}$ 

- [Unbiased estimators:]{.blue} $E(\hat{\theta})=E(\theta)$ On average, the estimates produced by some estimator will be centered around the truth

- [Consistent estimates:]{.blue} $\lim_{n\to \infty} \hat{\theta_N} = \theta$ As the sample size increases, the estimates from an estimator converge in probability to the parameter value

- [Statistic:]{.blue} A summary of the data (mean, regression coefficient, $R^2$). An estimator without a specified target of inference 

## Distrubtions and Standard Errors{.smaller}

- [Sampling Distribution:]{.blue} How some estimate would vary if you took repeated samples from the population

- [Standard Error:]{.blue} The standard deviation of the sampling distribution

- [Resampling Distribution:]{.blue} How some estimate would vary if you took repeated samples [from your sample WITH REPLACEMENT]{.blue} 
    - "Sampling from our sample, as the sample was sampled from the population."
    
## Confidence Intervals: Interpretation{.smaller}

- Confidence intervals give a range of values that are likely to include the true value of the parameter $\theta$ with probability $(1-\alpha) \times 100\%$

  - $\alpha = 0.05$ corresponds to a "95-percent confidence interval"

- Our "confidence" is about the interval
  
- In repeated sampling, we expect that $(1-\alpha) \times 100\%$ of the intervals we construct would contain the truth.

- For any one interval, the truth, $\theta$, either falls within in the lower and upper bounds of the interval or it does not.

## Calculating Confidence Intervals{.smaller}

In general, there are two ways to calculate confidence intervals:

- **Simulation:** Use our computers to simulate the idea of repeated sampling (e.g. bootstrapping)

  - Flexible, but more computationally intensive

- **Asymptotic Theory:** Use math to derive the properties of the distributions that would arise under repeated sampling
  
  - Faster, but requires more assumptions that may not hold

We will consider both. 

- The theory of CIs is easier to illustrate via simulation

- The practice of calculating CIs is (generally) easier using asymptotic theory


# {{< fa code >}} Bootstrapped Confidence Intervals {.inverse}

## The Population

```{r}
#


df %>% 
  ggplot(aes(age))+
  geom_density()+
  geom_rug()+
  stat_function(
    fun = mean,
    geom = "vline",
    aes(xintercept = after_stat(y))
  )+
  xlim(x=0,100)+
  ylim(0,.03)

df %>% 
  slice_sample(n=25) ->tmp
mean(df$age,na.rm=T)
tmp %>% 
  ggplot(aes(age))+
  geom_density()+
  geom_rug()+
  stat_function(
    fun = mean,
    args = list(na.rm=T),
    geom = "vline",
    aes(xintercept = after_stat(y))
  )+
  xlim(x=0,100)+
  ylim(0,.03)  
```

## A Single Sample


## Repeated Samples

```{r}
# ---- Population ----

# Population average
mu_age <- mean(df$age, na.rm=T)
# Population standard deviation
sd_age <- sd(df$age, na.rm = T)


# Sample Data

sample_data_fn <- function(dat=df, var=age, samps=16, sample_size=10){
  df <- tibble(
  sim = 1:samps,
  distribution = "Sampling",
  size = sample_size,
  sample_from = "Population",
  pop_mean = dat %>% pull(!!enquo(var)) %>% mean(., na.rm=T),
) %>% 
  mutate(
    sample = purrr::map(sim, ~ slice_sample(dat %>% select(!!enquo(var)), n = sample_size, replace = F)),
    sample_mean = purrr::map_dbl(sample, \(x) x %>% pull(!!enquo(var)) %>% mean(.,na.rm=T))
  )
  return(df)
}
plot_distribution <- function(x){
  mu <- mean(x$age,na.rm=T)
  x %>% 
    ggplot(aes(age))+
    geom_density()+
    geom_rug()+
    theme_void()+
    geom_vline(xintercept = mu, col = "red")+
    geom_vline(xintercept = mu_age, col = "grey",linetype = "dashed")+
    xlim(0,95)
}

plot_samples <- function(x){
  sample_plots <- x$sample[1:16] %>% 
  purrr::map( \(x) plot_distribution(x))
  p <- wrap_elements(wrap_plots(sample_plots[1:16], ncol=4))
  return(p)
  
}
plot_distribution(tmp)
tmp <- sample_data_fn(df)
test <- plot_samples(tmp)
test+labs(title="men")
test <- test +plot_annotation(title = "Meh")
test /test +plot_annotation(title = "Meh")
plot_figure_fn <- function(d=df, v=age, sim=1000, size=10){
  # Population average
  mu <- d %>% pull(!!enquo(v)) %>% mean(., na.rm=T)
  # Population standard deviation
  # Sample data
  samp_df <- sample_data_fn(dat=d, var = !!enquo(v), samps = sim, sample_size = size)
  # Plot Population
  p_pop <- d %>%
  ggplot(aes(!!enquo(v)))+
  geom_density(col ="grey60")+
  geom_rug(col = "grey60", )+
  geom_vline(xintercept = mu, col="grey40", linetype="dashed")+
  theme_void()+
  labs(title ="Population")
  
  p_samps <- plot_samples(samp_df)
  p_samps <- p_samps + ggtitle(paste("Repeated samples of size N =",size,"from the population"))
  
  p_dist <- samp_df %>% 
  ggplot(aes(sample_mean))+
  geom_density(col="red")+
  geom_rug(col="red")+
  geom_density(data = df, aes(age),
               col="grey")+
  geom_vline(xintercept = mu, linetype="dashed")+
  theme_void()+
    labs(
      title = "Sampling Distribution"
    )
  
  design <-"##AAAA##
            ##AAAA##
            ##AAAA##
            ########
            #BBBBBB#
            #BBBBBB#
            #BBBBBB#
            #BBBBBB#
            ########
            ##CCCC##
            ##CCCC##
            ##CCCC##"
  
  fig <- p_pop / p_samps / p_dist +
    plot_layout(design = design)
  return(fig)


  
  
  
}
plot_figure_fn()



# Samples
n_samples <- 1000 # Number of samples to draw


# N=10
sample_size <- 10 # Number of observations in each sample
set.seed(123) # random seed so we get the same "random" sample

age_samp_dist_n10 <- tibble(
  sim = 1:n_samples,
  distribution = "Sampling",
  size = sample_size,
  sample_from = "Population",
  pop_mean = mu_age,
) %>%
  mutate(
    sample = purrr::map(sim, ~ slice_sample(df, n = sample_size, replace = F)),
    sample_mean = purrr::map_dbl(sample, ~ mean(.$age, na.rm=T))
  )

sample_size <- 25 # Number of observations in each sample
set.seed(123) # random seed so we get the same "random" sample
age_samp_dist_n25 <- tibble(
  sim = 1:n_samples,
  distribution = "Sampling",
  size = sample_size,
  sample_from = "Population",
  pop_mean = mu_age,
) %>%
  mutate(
    sample = purrr::map(sim, ~ slice_sample(df, n = sample_size, replace = F)),
    sample_mean = purrr::map_dbl(sample, ~ mean(.$age, na.rm=T))
  )

sample_size <- 100 # Number of observations in each sample
set.seed(123) # random seed so we get the same "random" sample
age_samp_dist_n100 <- tibble(
  sim = 1:n_samples,
  distribution = "Sampling",
  size = sample_size,
  sample_from = "Population",
  pop_mean = mu_age,
) %>%
  mutate(
    sample = purrr::map(sim, \(x) slice_sample(df, n = sample_size, replace = F)), 
    sample_mean = purrr::map_dbl(sample, ~ mean(.$age, na.rm=T))
  )

# Sample Data







p2 <- plot_samples(age_samp_dist_n10)
p2 <- p2+plot_annotation(title = "Meh")
p2
plot_sampling_distribution(age_samp_dist_n25)
plot_sampling_distribution(age_samp_dist_n100)



p3 <- age_samp_dist_n25 %>% 
  ggplot(aes(sample_mean))+
  geom_density(col="red")+
  geom_rug(col="red")+
  geom_density(data = df, aes(age),
               col="grey")+
  geom_vline(xintercept = mu_age, linetype="dashed")+
  theme_void()

ggplot(tibble(x=1, y=1,),aes(x,y))+
  geom_abline(slope = .5,intercept = 0)+
  theme_void(
    
  )+
  theme(plot.margin = margin(0, 0, 0, 0))


design <- "##AAA##
           ##AAA##
           ##AAA##
           #BBBBB#
           #DDDDD#
           #DDDDD#
           #DDDDD#
           #DDDDD#
           #######
           ##EEE##
           ##EEE##
           ##EEE##"

# (plot_spacer() +p1 +plot_spacer() )/p2/ (plot_spacer() +p3+plot_spacer() ) +
test <-  p1/p_upper/p2/p3+
  plot_layout(design = design)

library(gridExtra)

test+
  geom_segment(tibble(x = 1, xend=3, y=1,yend=3),
               aes(x=x, xend=xend, y=y, yend=yend))


```


## Confidence Intervals

## Overview

# {{< fa code >}} Hypothesis Testing {.inverse}

## Overview




## Concept


# {{< fa code>}} Code {.inverse}

## Code

# {{< fa home >}} Summary {.inverse}

## Summary



## References